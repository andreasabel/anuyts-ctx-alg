{-# OPTIONS --cubical --type-in-type #-}

open import Cubical.Foundations.Everything renaming (Iso to _‚âÖ_ ; funExt‚Åª to _‚â°$_)
open import Cubical.Data.List hiding ([_])
open import Cubical.Data.List.Properties
open import Cubical.Data.List.FinData renaming (lookup to _!_)
open import Cubical.Data.Prod
open import Cubical.Data.W.Indexed
open import Cubical.Data.FinData
open import Cubical.Data.Sum
open import Cubical.Data.Sum as ‚äé
open import Cubical.Data.Empty
open import Cubical.Data.Nat
open import Cubical.Data.Sigma.Properties
open import Cubical.Foundations.Structure
open import Cubical.Categories.Category
open import Cubical.Categories.Category.Precategory hiding (_[_,_] ; seq')
open import Cubical.Categories.Functor renaming (ùüô‚ü®_‚ü© to ftrId)
open import Cubical.Categories.Instances.Sets
open import Cubical.Categories.Instances.Categories
open import Cubical.Categories.Constructions.Product
open import Cubical.Categories.Monad.Base
open import Cubical.Categories.NaturalTransformation.Base
open import Cubical.Categories.Instances.FunctorAlgebras
open import Cubical.Categories.Instances.EilenbergMoore
open import Cubical.Categories.Adjoint
open import Cubical.Categories.Limits.Initial

open import Mat.Signature
open import Mat.Free.Presentation

-- Terms of the free MAT generated by a free MAT presentation
module Mat.Free.Term {sign : Signature} (fmat : PresentationF sign) where

open _‚âÖ_
open Category renaming (_‚àò_ to _‚äö_)
open Functor
open Signature sign
open PresentationF fmat
open Algebra renaming (str to algStr)
open AlgebraHom
open IsEMAlgebra
open NaturalBijection
open _‚ä£_

-- Free syntax monad
data TermF (X : MType) : (sortOut : Sort) ‚Üí Type
isSetTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (TermF (mtyp msetX) sortOut)

-- TermF acting on MSets
msetTermF : MSet ‚Üí MSet
fst (msetTermF msetX sortOut) = TermF (mtyp msetX) sortOut
snd (msetTermF msetX sortOut) = isSetTermF msetX sortOut

data TermF X where
  varF : ‚àÄ {sortOut} ‚Üí X sortOut ‚Üí TermF X sortOut
  astF : ‚àÄ {sortOut} ‚Üí Term1 (TermF X) sortOut ‚Üí TermF X sortOut

-- TermF is really an IW type
module _ where
  RepTermF : (X : MType) (sortOut : Sort) ‚Üí Type
  RepTermF X sortOut =
    IW (Œª sort ‚Üí X sort ‚äé Operation sort)
      (Œª sort ‚Üí ‚äé.elim (Œª v ‚Üí ‚ä•) Œª o ‚Üí Fin (length (arity o)))
      (Œª sort ‚Üí ‚äé.elim (Œª v ()) (Œª o p ‚Üí arity o ! p))
      sortOut

  toRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚Üí RepTermF X sortOut
  toRepTermF X sortOut (varF v) = node (inl v) (Œª ())
  toRepTermF X sortOut (astF (term1 o args)) =
    node (inr o) Œª p ‚Üí toRepTermF X (arity o ! p) (args p)

  fromRepTermF : (X : MType) (sortOut : Sort) ‚Üí RepTermF X sortOut ‚Üí TermF X sortOut
  fromRepTermF X sortOut (node (inl v) u) = varF v
  fromRepTermF X sortOut (node (inr o) args) = astF (term1 o Œª p ‚Üí fromRepTermF X (arity o ! p) (args p))

  fromToRepTermF : (X : MType) (sortOut : Sort) (t : TermF X sortOut)
    ‚Üí fromRepTermF X sortOut (toRepTermF X sortOut t) ‚â° t
  fromToRepTermF X sortOut (varF v) = refl
  fromToRepTermF X sortOut (astF (term1 o args)) i =
    astF (term1 o Œª p ‚Üí fromToRepTermF X (arity o ! p) (args p) i)

  toFromRepTermF : (X : MType) (sortOut : Sort) (rt : RepTermF X sortOut)
    ‚Üí toRepTermF X sortOut (fromRepTermF X sortOut rt) ‚â° rt
  toFromRepTermF X sortOut (node (inl v) u) = cong (node (inl v)) (funExt (Œª ()))
  toFromRepTermF X sortOut (node (inr o) args) i =
    node (inr o) (Œª p ‚Üí toFromRepTermF X (arity o ! p) (args p) i)

  isoRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚âÖ RepTermF X sortOut
  fun (isoRepTermF X sortOut) = toRepTermF X sortOut
  inv (isoRepTermF X sortOut) = fromRepTermF X sortOut
  rightInv (isoRepTermF X sortOut) = toFromRepTermF X sortOut
  leftInv (isoRepTermF X sortOut) = fromToRepTermF X sortOut

  pathRepTermF : (X : MType) (sortOut : Sort) ‚Üí TermF X sortOut ‚â° RepTermF X sortOut
  pathRepTermF X sortOut = ua (isoToEquiv (isoRepTermF X sortOut))

  isSetRepTermF : (msetX : MSet) (sortOut : Sort) ‚Üí isSet (RepTermF (mtyp msetX) sortOut)
  isSetRepTermF msetX sortOut = isOfHLevelSuc-IW 1 (Œª sort ‚Üí isSet‚äé (str (msetX sort)) isSetOperation) sortOut

isSetTermF msetX sortOut = subst‚Åª isSet (pathRepTermF (mtyp msetX) sortOut) (isSetRepTermF msetX sortOut)

-- components of TermF as a functor
mapTermF : ‚àÄ {X Y} ‚Üí (‚àÄ sort ‚Üí X sort ‚Üí Y sort) ‚Üí ‚àÄ sort ‚Üí TermF X sort ‚Üí TermF Y sort
mapTermF f sort (varF x) = varF (f sort x)
mapTermF f sort (astF (term1 o args)) = astF (term1 o Œª p ‚Üí mapTermF f (arity o ! p) (args p))

mapTermF-id : ‚àÄ {X} ‚Üí mapTermF (Œª sort ‚Üí idfun (X sort)) ‚â° (Œª sort ‚Üí idfun (TermF X sort))
mapTermF-id i sort (varF x) = varF x
mapTermF-id i sort (astF (term1 o args)) = astF (term1 o (Œª p ‚Üí mapTermF-id i (arity o ! p) (args p)))

mapTermF-‚àò : ‚àÄ {X Y Z : MType} ‚Üí (g : ‚àÄ sort ‚Üí Y sort ‚Üí Z sort) ‚Üí (f : ‚àÄ sort ‚Üí X sort ‚Üí Y sort) ‚Üí
  mapTermF (Œª sort ‚Üí g sort ‚àò f sort) ‚â° (Œª sort ‚Üí mapTermF g sort ‚àò mapTermF f sort)
mapTermF-‚àò g f i sort (varF x) = varF (g sort (f sort x))
mapTermF-‚àò g f i sort (astF (term1 o args)) = astF (term1 o (Œª p ‚Üí mapTermF-‚àò g f i (arity o ! p) (args p)))

-- TermF as a functor on catMSet
ftrTermF : Functor catMSet catMSet
F-ob ftrTermF = msetTermF
F-hom ftrTermF = mapTermF
F-id ftrTermF = mapTermF-id
F-seq ftrTermF f g = mapTermF-‚àò g f

open NatTrans

-- components of TermF as a monad

pureTermF : ‚àÄ {X} sort ‚Üí X sort ‚Üí TermF X sort
pureTermF sort = varF

Œ∑TermF : NatTrans (ftrId catMSet) ftrTermF
N-ob Œ∑TermF msetX sortOut = varF
N-hom Œ∑TermF {msetX} {msetY} f = refl

joinTermF : ‚àÄ {X} sort ‚Üí TermF (TermF X) sort ‚Üí TermF X sort
joinTermF sort (varF t) = t
joinTermF sort (astF (term1 o args)) = astF (term1 o (Œª p ‚Üí joinTermF (arity o ! p) (args p)))

joinTermF-nat : ‚àÄ {X Y : MType} f sort ‚Üí (t : TermF (TermF X) sort)
  ‚Üí joinTermF {X = Y} sort (mapTermF (mapTermF f) sort t) ‚â° mapTermF f sort (joinTermF sort t)
joinTermF-nat f sort (varF t) = refl
joinTermF-nat f sort (astF (term1 o args)) i = astF (term1 o Œª p ‚Üí joinTermF-nat f (arity o ! p) (args p) i)

ŒºTermF : NatTrans (funcComp ftrTermF ftrTermF) ftrTermF
N-ob ŒºTermF msetX = joinTermF
N-hom ŒºTermF {msetX} {msetY} f = funExt Œª sort ‚Üí funExt Œª t ‚Üí joinTermF-nat f sort t

open IsMonad

-- TermF is a monad
ismonadTermF : IsMonad ftrTermF
Œ∑ ismonadTermF = Œ∑TermF
Œº ismonadTermF = ŒºTermF
idl-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-rUnit i) (Œª i ‚Üí ftrTermF) refl
idr-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-lUnit i) (Œª i ‚Üí ftrTermF) lemma
  where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF (Œª sortOut ‚Üí varF) sort t)) ‚â°
                (Œª msetX sort t ‚Üí t)
        lemma i msetX sort (varF x) = varF x
        lemma i msetX sort (astF (term1 o args)) = astF (term1 o Œª p ‚Üí lemma i msetX (arity o ! p) (args p))
assoc-Œº ismonadTermF = makeNatTransPathP (Œª i ‚Üí F-assoc i) (Œª i ‚Üí ftrTermF) lemma
  where lemma : (Œª msetX sort t ‚Üí joinTermF sort (mapTermF joinTermF sort t)) ‚â°
                (Œª msetX sort t ‚Üí joinTermF sort (joinTermF sort t))
        lemma i msetX sort (varF ttx) = joinTermF sort ttx
        lemma i msetX sort (astF (term1 o args)) = astF (term1 o Œª p ‚Üí lemma i msetX (arity o ! p) (args p))

monadTermF : Monad catMSet
monadTermF = ftrTermF , ismonadTermF

-- Models are Eilenberg-Moore algebras of monadTermF
catModelF : Category ‚Ñì-zero ‚Ñì-zero
catModelF = EMCategory monadTermF

ModelF : Type ‚Ñì-zero
ModelF = ob catModelF

ModelFHom : (mFA mFB : ModelF) ‚Üí Type ‚Ñì-zero
ModelFHom = Hom[_,_] catModelF

-- Forgetful functor sending models to their carrier
ftrForgetModelF : Functor catModelF catMSet
ftrForgetModelF = ForgetEMAlgebra monadTermF

-- Free model functor
ftrFreeModelF : Functor catMSet catModelF
ftrFreeModelF = FreeEMAlgebra monadTermF

adjModelF : ftrFreeModelF ‚ä£ ftrForgetModelF
adjModelF = emAdjunction monadTermF

-- Recursion/folding (with metavariables) and properties

mFFoldModelF : (msetX : MSet) ‚Üí (mFA : ModelF)
  ‚Üí catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  ‚Üí catModelF [ F-ob ftrFreeModelF msetX , mFA ]
mFFoldModelF msetX mFA = _‚ôØ adjModelF {c = msetX} {d = mFA}

foldModelF : (msetX : MSet) ‚Üí (mFA : ModelF)
  ‚Üí catMSet [ msetX , F-ob ftrForgetModelF mFA ]
  ‚Üí ‚àÄ sort ‚Üí TermF (mtyp msetX) sort ‚Üí typ (carrier (fst mFA) sort)
foldModelF msetX mFA f = mFFoldModelF msetX mFA f .carrierHom

mFFoldModelF-nat :  (msetX : MSet) ‚Üí (mFA mFB : ModelF)
  ‚Üí (mFG : catModelF [ mFA , mFB ])
  ‚Üí (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  ‚Üí mFFoldModelF msetX mFB (_‚ãÜ_
      catMSet
      {x = msetX}
      {y = F-ob ftrForgetModelF mFA}
      {z = F-ob ftrForgetModelF mFB}
      f
      (F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG)
    )
  ‚â° _‚ãÜ_ catModelF {x = F-ob ftrFreeModelF msetX} {mFA} {mFB} (mFFoldModelF msetX mFA f) mFG
mFFoldModelF-nat msetX mFA mFB mFG f =
  sym (adjNatInD' adjModelF {c = msetX} {d = mFA} {d' = mFB} f mFG)

foldModelF-nat : (msetX : MSet) ‚Üí (mFA mFB : ModelF)
  ‚Üí (mFG : catModelF [ mFA , mFB ])
  ‚Üí (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  ‚Üí foldModelF msetX mFB (Œª sort ‚Üí F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort ‚àò f sort)
   ‚â° (Œª sort ‚Üí F-hom ftrForgetModelF {x = mFA} {y = mFB} mFG sort ‚àò foldModelF msetX mFA f sort)
foldModelF-nat msetX mFA mFB mFG f i = mFFoldModelF-nat msetX mFA mFB mFG f i .carrierHom

mFFoldModelF-uniq : (msetX : MSet) ‚Üí (mFA : ModelF)
  ‚Üí (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  ‚Üí (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  ‚Üí (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort) ‚â° f
  ‚Üí mFFoldModelF msetX mFA f ‚â° mFG
mFFoldModelF-uniq msetX mFA f mFG ef =
  mFFoldModelF msetX mFA f
    ‚â°‚ü®‚ü©
  _‚ôØ adjModelF {c = msetX} {d = mFA} f
    ‚â°‚ü® cong (_‚ôØ adjModelF {c = msetX} {d = mFA}) (sym ef) ‚ü©
  _‚ôØ adjModelF {c = msetX} {d = mFA} (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort)
    ‚â°‚ü®‚ü©
  _‚ôØ adjModelF {c = msetX} {d = mFA} (_‚ô≠ adjModelF {c = msetX} {d = mFA} mFG)
    ‚â°‚ü® adjModelF .adjIso {c = msetX} {d = mFA} .leftInv mFG ‚ü©
  mFG ‚àé

foldModelF-uniq : (msetX : MSet) ‚Üí (mFA : ModelF)
  ‚Üí (f : catMSet [ msetX , F-ob ftrForgetModelF mFA ])
  ‚Üí (mFG : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  ‚Üí (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort) ‚â° f
  ‚Üí foldModelF msetX mFA f ‚â° mFG .carrierHom
foldModelF-uniq msetX mFA f mFG ef i = mFFoldModelF-uniq msetX mFA f mFG ef i .carrierHom

foldModelF-uniq2 : (msetX : MSet) ‚Üí (mFA : ModelF)
  ‚Üí (mFG mFH : catModelF [ F-ob ftrFreeModelF msetX , mFA ])
  ‚Üí (Œª (sort : Sort) ‚Üí mFG .carrierHom sort ‚àò pureTermF sort)
   ‚â° (Œª (sort : Sort) ‚Üí mFH .carrierHom sort ‚àò pureTermF sort)
  ‚Üí mFG .carrierHom ‚â° mFH .carrierHom
foldModelF-uniq2 msetX mFA mFG mFH e =
  mFG .carrierHom
    ‚â°‚ü® sym (foldModelF-uniq msetX mFA (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort) mFG refl) ‚ü©
  foldModelF msetX mFA (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort)
    ‚â°‚ü® foldModelF-uniq msetX mFA (Œª sort ‚Üí mFG .carrierHom sort ‚àò pureTermF sort) mFH (sym e) ‚ü©
  mFH .carrierHom ‚àé

-- Sending models of Term1 to models of TermF
module _ where
  model1‚ÜíF-algStr : ((algebra msetA Œ±) : Model1) ‚Üí IsAlgebra ftrTermF msetA
  model1‚ÜíF-algStr (algebra msetA Œ±) sort (varF a) = a
  model1‚ÜíF-algStr (algebra msetA Œ±) sort (astF (term1 o args)) =
    Œ± sort (term1 o Œª p ‚Üí model1‚ÜíF-algStr (algebra msetA Œ±) (arity o ! p) (args p))

  model1‚ÜíF-algStr-joinTermF :
    ((algebra msetA Œ±) : Model1) ‚Üí
    ‚àÄ sort ‚Üí
    (tta : TermF (Œª sort‚ÇÅ ‚Üí TermF (Œª sort‚ÇÇ ‚Üí fst (msetA sort‚ÇÇ)) sort‚ÇÅ) sort) ‚Üí
    model1‚ÜíF-algStr (algebra msetA Œ±) sort (joinTermF sort tta) ‚â°
    model1‚ÜíF-algStr (algebra msetA Œ±) sort (mapTermF (model1‚ÜíF-algStr (algebra msetA Œ±)) sort tta)
  model1‚ÜíF-algStr-joinTermF (algebra msetA Œ±) sort (varF ta) = refl
  model1‚ÜíF-algStr-joinTermF (algebra msetA Œ±) sort (astF (term1 o args)) =
    cong (Œ± sort) (cong (term1 o) (funExt Œª p ‚Üí model1‚ÜíF-algStr-joinTermF (algebra msetA Œ±) (arity o ! p) (args p)))

  model1‚ÜíF : Model1 ‚Üí ModelF
  carrier (fst (model1‚ÜíF (algebra msetA Œ±))) = msetA
  algStr (fst (model1‚ÜíF (algebra msetA Œ±))) = model1‚ÜíF-algStr (algebra msetA Œ±)
  str-Œ∑ (snd (model1‚ÜíF (algebra msetA Œ±))) = refl
  str-Œº (snd (model1‚ÜíF (algebra msetA Œ±))) = funExt Œª sort ‚Üí funExt Œª tta ‚Üí model1‚ÜíF-algStr-joinTermF (algebra msetA Œ±) sort tta

  model1‚ÜíF-ishom : ‚àÄ {(algebra msetA Œ±) (algebra msetB Œ≤) : Algebra ftrTerm1} ‚Üí ((algebraHom f isalgF)
    : Model1Hom (algebra msetA Œ±) (algebra msetB Œ≤)) ‚Üí ‚àÄ sort ta
    ‚Üí f sort (model1‚ÜíF-algStr (algebra msetA Œ±) sort ta) ‚â° model1‚ÜíF-algStr (algebra msetB Œ≤) sort (mapTermF f sort ta)
  model1‚ÜíF-ishom {algebra msetA Œ±} {algebra msetB Œ≤} (algebraHom f commut) sort (varF a) = refl
  model1‚ÜíF-ishom {algebra msetA Œ±} {algebra msetB Œ≤} (algebraHom f commut) sort (astF (term1 o args)) =
    f sort (Œ± sort (term1 o (Œª p ‚Üí model1‚ÜíF-algStr (algebra msetA Œ±) (arity o ! p) (args p))))
      ‚â°‚ü® commut' sort (term1 o Œª p ‚Üí model1‚ÜíF-algStr (algebra msetA Œ±) (arity o ! p) (args p)) ‚ü©
    Œ≤ sort (term1 o (Œª p ‚Üí f (arity o ! p) (model1‚ÜíF-algStr (algebra msetA Œ±) (arity o ! p) (args p))))
      ‚â°‚ü® cong (Œ≤ sort) (cong (term1 o) (funExt Œª p ‚Üí model1‚ÜíF-ishom (algebraHom f commut) (arity o ! p) (args p))) ‚ü©
    Œ≤ sort (term1 o (Œª p ‚Üí model1‚ÜíF-algStr (algebra msetB Œ≤) (arity o ! p) (mapTermF f (arity o ! p) (args p)))) ‚àé
    where commut' : ‚àÄ sort ((term1 o' args') : Term1 (mtyp msetA) sort)
                  ‚Üí f sort (Œ± sort (term1 o' args')) ‚â° Œ≤ sort (term1 o' Œª p ‚Üí f (arity o' ! p) (args' p))
          commut' sort ta i = commut i sort ta

  model1‚ÜíF-hom : ‚àÄ {m1A m1B} ‚Üí (m1F : Model1Hom m1A m1B) ‚Üí ModelFHom (model1‚ÜíF m1A) (model1‚ÜíF m1B)
  carrierHom (model1‚ÜíF-hom {algebra msetA Œ±} {algebra msetB Œ≤} (algebraHom f commut)) = f
  strHom (model1‚ÜíF-hom {algebra msetA Œ±} {algebra msetB Œ≤} (algebraHom f commut)) =
    funExt Œª sort ‚Üí funExt Œª ta ‚Üí model1‚ÜíF-ishom (algebraHom f commut) sort ta

  ftrModel1‚ÜíF : Functor catModel1 catModelF
  F-ob ftrModel1‚ÜíF = model1‚ÜíF
  F-hom ftrModel1‚ÜíF = model1‚ÜíF-hom
  F-id ftrModel1‚ÜíF = AlgebraHom‚â° ftrTermF refl
  F-seq ftrModel1‚ÜíF algF algG = AlgebraHom‚â° ftrTermF refl

-- sending models of TermF to models of Term1
module _ where
  nt1‚ÜíF : NatTrans ftrTerm1 ftrTermF
  N-ob nt1‚ÜíF msetA sort (term1 o args) = astF (term1 o Œª p ‚Üí varF (args p))
  N-hom nt1‚ÜíF f = refl

  ftrModelF‚Üí1 : Functor catModelF catModel1
  ftrModelF‚Üí1 = funcComp {-{D = AlgebrasCategory ftrTermF}{E = catModel1}{C = catModelF}-}
    (AlgebrasFunctor {F = ftrTerm1} {G = ftrTermF} nt1‚ÜíF)
    (ForgetEM monadTermF)

  modelF‚Üí1 : ModelF ‚Üí Model1
  modelF‚Üí1 = F-ob ftrModelF‚Üí1

-- Isomorphism components of Model1 ‚Üî ModelF
module _ where
  ftrModel1‚ÜíF‚Üí1 : funcComp ftrModelF‚Üí1 ftrModel1‚ÜíF ‚â° ftrId catModel1
  ftrModel1‚ÜíF‚Üí1 = Functor‚â°
    (Œª (algebra msetA Œ±) ‚Üí refl)
    (Œª where
      {algebra msetA Œ±} {algebra msetB Œ≤} (algebraHom f isalgF) ‚Üí AlgebraHom‚â° ftrTerm1 refl
    )

  ftrModelF‚Üí1‚ÜíF : funcComp ftrModel1‚ÜíF ftrModelF‚Üí1 ‚â° ftrId catModelF
  ftrModelF‚Üí1‚ÜíF = Functor‚â°
    (Œª where
      (algebra msetA Œ± , isEMA) ‚Üí Œ£‚â°Prop
        (Œª algA ‚Üí isPropIsEMAlgebra monadTermF)
        (cong (algebra msetA) (funExt Œª sort ‚Üí funExt Œª ta ‚Üí lemma (algebra msetA Œ±) isEMA sort ta))
    )
    (Œª where
      {algebra msetA Œ± , isEMA} {algebra msetB Œ≤ , isEMB} (algebraHom f isalgF) ‚Üí
        AlgebraHomPathP ftrTermF refl
    )
    where
      open IsEMAlgebra
      lemma : ‚àÄ ((algebra msetA Œ±) : Algebra ftrTermF) (isEMA : IsEMAlgebra monadTermF (algebra msetA Œ±))
        (sort : Sort) (ta : TermF (Œª sort‚ÇÅ ‚Üí fst (msetA sort‚ÇÅ)) sort) ‚Üí
        model1‚ÜíF-algStr (algebra msetA (Œª sort' (term1 o args) ‚Üí Œ± sort' (astF (term1 o Œª p ‚Üí varF (args p))))) sort ta
        ‚â° Œ± sort ta
      lemma (algebra msetA Œ±) isEMA sort (varF a) = sym ((str-Œ∑ isEMA ‚â°$ sort) ‚â°$ a)
      lemma (algebra msetA Œ±) isEMA sort (astF (term1 o args)) =
        Œ± sort (astF (term1 o Œª p ‚Üí varF (model1‚ÜíF-algStr (algebra msetA (Œª sort' (term1 o' args') ‚Üí
                    Œ± sort' (astF (term1 o' Œª p‚ÇÅ ‚Üí varF (args' p‚ÇÅ))))) (arity o ! p) (args p))))
          ‚â°‚ü® cong (Œ± sort) (cong astF (cong (term1 o) (funExt Œª p
              ‚Üí cong varF (lemma (algebra msetA Œ±) isEMA (arity o ! p) (args p))))) ‚ü©
        -- (Œ± ‚àò Œ£ var ‚àò Œ£ Œ±) (astF (term1 o args))
        Œ± sort (astF (term1 o Œª p ‚Üí varF (Œ± (arity o ! p) (args p))))
          ‚â°‚ü®‚ü©
        -- (Œ± ‚àò Œ£ Œ£* Œ± ‚àò Œ£ var) (astF (term1 o args))
        Œ± sort (astF (term1 o Œª p ‚Üí mapTermF Œ± (arity o ! p) (varF (args p))))
          ‚â°‚ü® sym ((str-Œº isEMA ‚â°$ sort) ‚â°$ astF (term1 o Œª p ‚Üí varF (args p))) ‚ü©
        -- (Œ± ‚àò Œ£ ¬µ ‚àò Œ£ var) (astF (term1 o args))
        Œ± sort (joinTermF sort (astF (term1 o Œª p ‚Üí varF (args p))))
          ‚â°‚ü®‚ü©
        Œ± sort (astF (term1 o args)) ‚àé

-- Model1 ‚âÖ ModelF
open PrecatIso
isoftrModel1‚âÖF : PrecatIso (CatPrecategory ‚Ñì-zero ‚Ñì-zero) catModel1 catModelF
mor isoftrModel1‚âÖF = ftrModel1‚ÜíF
inv isoftrModel1‚âÖF = ftrModelF‚Üí1
sec isoftrModel1‚âÖF = ftrModelF‚Üí1‚ÜíF
ret isoftrModel1‚âÖF = ftrModel1‚ÜíF‚Üí1

-- Syntax object
module _ where

  SyntaxF : MType
  SyntaxF = TermF (mtyp msetEmpty)

  msetSyntaxF : MSet
  msetSyntaxF = msetTermF msetEmpty

  mFSyntaxF : ModelF
  mFSyntaxF = F-ob ftrFreeModelF msetEmpty

  open NaturalBijection

  isInitial-mFSyntaxF : isInitial catModelF mFSyntaxF
  isInitial-mFSyntaxF = isLeftAdjoint‚ÜípreservesInitial
    {C = catMSet}
    {D = catModelF}
    ftrFreeModelF
    (ftrForgetModelF , emAdjunction monadTermF)
    msetEmpty
    isInitial-msetEmpty

  m1SyntaxF : Model1
  m1SyntaxF = F-ob ftrModelF‚Üí1 mFSyntaxF

  {- Ways to prove initiality of m1SyntaxF:
     - directly (seems stupid)
     - prove that isomorphic precategories are equal
     - prove that mutually inverse functors are adjoint
  -}
